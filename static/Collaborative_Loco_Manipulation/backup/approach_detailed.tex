\section{Distributed Optimization}
\label{sec:approach}
% To better illustrate our distributed optimization formulation, we rewrite the centralized formulation with separate dynamics modeling for both the payload and the robots as the following:
% \begin{subequations} 
% \begin{align}
% 	\underset{\v U, \v X}{\text{min}} \ \mathcal{C}(\v U, \v X) \coloneqq & \sum_{k = 0}^{N-1}l_k(\v x[k], \v u[k]) + l_N(\v x[N]) \\
% 	\text{s.t.} \quad & \v x_{0}[k+1] = \mathcal{D}^0(\v x_{0}[k], \v u_{i}[k]) \\
%     % & \v g^0(\v x_{0, k}, \v u_{0, k}) = 0 \\
%     & \v h_0(\v x_{0}[k], \v x_{i}[k], \v u_{0}[k]) \leq 0\\
%     & \forall i \in \{1, \dots, R\} \nonumber\\
%     & \v x_{i}[k+1] = \mathcal{D}^i(\v x_{i}[k], \v x_{0}[k], \v u_{i}[k]) \\
%     & \v g_i(\v x_{i}[k], \v u_{i}[k]) = 0 \\
%     & \v h_i(\v x_{i}[k], \v x_{0}[k], \v u_{i}[k]) \leq 0
% \end{align}
% \end{subequations}
% where $\mathcal{D}^{0}$ and $\mathcal{D}^{i}$ correspond to the subsystem dynamics Eqs.~(\ref{eq:payload_dynamics}) and (\ref{eq:robot_dynamics}) respectively. It can be seen that each dynamics equation and inequality constraints still depend not only single payload/robot state but also other system's states. For the latter case, we call them inter-system constraints. Therefore, one major contribution of this work is to develop an optimization framework that further separates each subsystem so that each subproblem can be solved in parallel to accelerate the computational time.

From previous section, it can be seen that each dynamics equation and part of the inequality constraints still depend not only single payload/robot state but also other system's states. For the latter case, we call them inter-system constraints. Therefore, one major contribution of this work is to develop an optimization framework that further separates each subsystem so that each subproblem can be solved in parallel to accelerate the computational time.

\subsection{Decomposed System Dynamics}
To apply ADMM, we first create the control variables $\v u_0$ for the payload, which consists of global copies of the manipulation wrench including force and torque variables applied by each robot:
\begin{equation}
    \begin{aligned}
        \v u_{0}[k] := [\bar{\v f}_{i,h}[k]^{\top}, \bar{\vg \tau}_{i,h}[k]^{\top}]^{\top}, i \in \{1, \dots, R\}
    \end{aligned}
\end{equation}


For better illustration of each subsystem, we use $\vg \phi_i = [\v x_i[0,\dots,N], \v u_i[0,\dots,N-1]]^{\top}$ to express the trajectory of the concatenated state and control variables for the $i^{\textit{th}}$ rigid body. Then we build consensus constraint for the manipulation force and torque variables between the payload and robot states based on the Newton's law:
\begin{subequations}\label{eq:consensus_constraint}
    \begin{align}
        & \forall i \in \{1, \dots, R\},\\
        & \v f_{i,h}[k] + \bar{\v f}_{i,h}[k] = 0,\\
        & \vg \tau_{i,h}[k] + \bar{\vg \tau}_{i,h}[k] = 0
    \end{align}
\end{subequations}

\begin{remark}\label{remark:consensus}
Instead of introducing consensus copies of both state and control variables for each robot’s neighbor (the payload), we deliberately avoid enforcing state consensus to prevent unnecessary state augmentation. For a single quadruped manipulator, even using a simplified model, the subsystem already has a high-dimensional state (24 states), making the computational cost highly sensitive to further state expansion. Moreover, unlike contact-implicit formulations \cite{shorinwa_disco_2024}, the dynamic coupling between the robots and the payload in our static grasping setup is dominated by interaction forces and torques rather than state variables. Consequently, for dynamics and inter-system constraints that involve state variables from other subsystems, we use the values from the previous ADMM iteration. This approximation has been empirically shown to have negligible impact on performance while significantly improving computational efficiency, consistent with observations in \cite{amatucci2022}.
\end{remark}
By establishing local copies, the payload dynamics can get rid of the dependency on $\v u_i (i > 0)$ and replace with the new control variable $\v u_0$. To consider the coupling effects from the payload state in the robot dynamics without creating payload state copies, we use the payload states from the previous ADMM iteration as described in Remark \ref{remark:consensus}. The discrete dynamics equations for the payload and robots at the $m+1^{\text{th}}$ ADMM iteration can be written as:
\begin{subequations}
    \begin{align}
        & \v x_{0}^{m+1}[k+1] = \mathcal{D}^0(\v x_{0}^{m+1}[k], \v u_{0}^{m+1}[k])\\
        & \v x_{i}^{m+1}[k+1] = \mathcal{D}^i(\v x_{i}^{m+1}[k], \v x_{0}^{m}[k], \v u_{i}^{m+1}[k])
    \end{align}
\end{subequations}
Then at the $m+1^{\text{th}}$ ADMM iteration, the states from $m^{\text{th}}$ ADMM iteration can be treated as constant variables. 

\subsection{Constraints}
The constraints can be divided into independent ones and the inter-system ones. The independent ones refer to the constraints that do not involve variables from other subsystems, including the frictional and contact, foot kinematics, placement, and collision avoidance constraints. The inter-system ones include the arm kinematics and formation constraints, which involve both the robot and the payload states. The detailed formulation can be provided as following:
\subsubsection{Independent --- Frictional and Contact}
The manipulation contact wrench cone is simplified to a positive normal force constraint, a manipulation friction cone, and a bounding box $\mathcal{B}$ for the moment part defined in Eqs.~(\ref{eq:mani_force_non_zero}) - (\ref{eq:wrench_cone}).
Point-foot positive normal force and frictional constraints are defined in Eqs.~(\ref{eq:force_non_zero}) - (\ref{eq:force_friction_cone}). We define $\v n$ as the normal vector of the grasping point or the ground, corresponding to the payload orientation $\vg \theta_0$ or the foot EE tangential position $\v p^{xy}_{i,j}$ by inquiring the terrain map. The friction cone $\mathcal{F}$ depends on the friction coefficient $\mu$ and the normal vector. Contact constraints in Eqs.~(\ref{eq:ee_velocity_zero}) - (\ref{eq:force_zero}) forces the EE velocity to be zero during stance phase and the contact force to be zero during the non-contact phase. $\mathcal{C}_{i,j}$ represents the set of all time steps indicating stance for the $j^{\rm th}$ foot of the $i^{\rm th}$ robot.
\begin{align}
    \nonumber &\forall i \in [1,\dots,R], j \in [n_f]\\\label{eq:mani_force_non_zero}
    & \v f_{i,h}[k] \cdot \v n_{i,h}(\vg \theta_0[k]) \ge 0,\\
    \label{eq:wrench_cone}
        & \v f_{i,h}[k] \in \mathcal{F}(\mu, \v n_{i,h}), \vg \tau_{i,h} \in \mathcal{B}_{i,h}
        \\\label{eq:force_non_zero}
    & \v f_{i,j}[k] \cdot \v n_{i,j}(\v p_{i,j}^{xy}[k]) \ge 0, \ \forall k \in \mathcal{C}_{i,j}\\
    \label{eq:force_friction_cone}
        & \v f_{i,j}[k] \in \mathcal{F}(\mu, \v n_{i,j}), \ \forall k \in \mathcal{C}_{i,j}
         \\\label{eq:ee_velocity_zero}
            &\dot{\v p}_{i,j}[k]=0, \ \forall k \in \mathcal{C}_{i,j}
        \\\label{eq:force_zero}
         &\v f_{i,j}[k] = 0, \ \forall i \notin \mathcal{C}_{i,j}
\end{align}
%
where $\mu$ denotes the friction coefficient.

% \subsubsection{Actuation Constraint}
% Since the joint angles are omitted in the single rigid body model, we use a fixed Jacobian $\v J_j(\v q_j^{\text{ref}})$ at a nominal joint pose $\v q_j^{\text{ref}}$ for each leg to approximately consider the torque limit constraint in Eq.~(\ref{eq:max_torque}). 
% % In addition, since the translational and angular motions are decoupled, another actuation constraint on the angular acceleration is also added in Eq.~(\ref{eq:max_acc}).
% \begin{align}
% \nonumber & \forall i \in [1,\dots,R], j \in [n_f] \\
%     \label{eq:max_torque}
% & \v J_{i,j}(\v q_j^{\text{ref}})^{\top} \v f_{i,j}[k] \leq \vg \tau_{\rm max}
% % \label{eq:max_acc}
% % & \v I \ddot{\vg \theta}[i] \leq \vg \tau_{\rm max}^{\prime}
% \end{align}
% where $\vg \tau_{\rm max}$ is the joint torque limit. 
% % $\vg \tau_{\rm max}^{\prime}$ is the torque limit applied on the base, and $\v I$ is the moment of inertia for the approximated single rigid body.

\subsubsection{Independent --- Foot Kinematics}
The kinematics constraint in Eq.~(\ref{eq:rom}) strictly limits the possible foot EE movements to assure safety and avoid singularity.
% Due to the convex nature of this MICP, we can determine the feasibility of a possible symbolic transition by checking if the optimal solution exists.
\begin{equation}
\begin{aligned}
    \nonumber
    & \forall i \in [1,\dots,R], j \in [n_f]\\
    \label{eq:rom}
    & \v p_{i,j}[k] \in \mathcal{R}_j(^\mathcal{B} \v p_j^{\text{ref}}, \v r_i[k],\vg \theta_{i}[k], \v p_j^{\text{max}})
\end{aligned}
\end{equation}
where $\mathcal{R}_j$ is defined as a 3D box constraint around a nominal foot EE position $^\mathcal{B} \v p_j^{\text{ref}}$ based on the robot base position and orientation, and constrained by a maximum deviation $\v p_j^{\text{max}}$.

\subsubsection{Independent --- Foot Placement}
Foot placement is applied on the robot side and has two modes.

\textbf{Non-perceptive mode}. A height-map constraint enforces that the foot height matches a given terrain height $h(x,y)$ during stance: $|\v p_{i,j}^z[k] - h(\v p_{i,j}^{xy}[k])| \leq \epsilon_h$ with a small tolerance $\epsilon_h$. When no terrain map is available, a default height is used.

\textbf{Perceptive mode}. When an elevation map and planar terrain decomposition are available (e.g., from \cite{miki2022elevation}), we use two complementary constraints. (1) \textit{Stance height:} For each stance foot, the height is constrained based on the height map.
% a band $[-\epsilon, \epsilon]$, with derivatives $\partial h / \partial x$, $\partial h / \partial y$ from the height map. 
(2) \textit{Stance polygon:} For each stance phase, a convex safe region in the plane is built from the terrain segmentation (convex polygon in a planar region). The foot's $(x,y)$ position is constrained to lie inside this polygon: $\v A_{\text{foot}} \, \v p_{i,j}[k] + \v b_{\text{foot}} \geq 0$, where $(\v A_{\text{foot}}, \v b_{\text{foot}})$ encode the polygon edges in world frame (via the region's plane-to-world transform). The polygon is selected heuristically for each stance phase similar to \cite{grandia2023perceptive}.

% The foot placement constraint is only applied to the robot side and can be divided into perceptive and non-perceptive mode. The perceptive mode relies on a terrain segmentation pipeline including elevation mapping and convex polygon segmentation. The landing foot EE height is then enforced by the terrain height, while the x and y dimensions are constrained by the heuristically selected terrain polygon similar to \cite{grandia2023perceptive}.

\subsubsection{Independent --- Collision Avoidance}
Both the payload and robots actively avoid obstacles using a Control Barrier Function (CBF) formulation. For each obstacle $\ell$ with center $\v c_\ell$, radius $\rho_\ell$, and margin $\Delta$, define $h_\ell \coloneqq \|\v r - \v c_\ell\|^2 - (\rho_\ell + \Delta)^2$, where $\v r$ is the agent position (payload $\v r_0$ in 3D, or robot base $\v r_i^{xy}$ in 2D). The safe set $\{h_\ell \geq 0\}$ is enforced as forward invariant by requiring
\begin{equation}
    h_\ell + \dot{h}_\ell \geq 0, \quad \dot{h}_\ell = 2(\v r - \v c_\ell)^\top \dot{\v r},
\end{equation}
at each time step. This constraint is applied for the payload and each robot against all obstacles. Similarly, a terrain-aware constraint is imposed on the payload to prevent collisions during terrain transitions, such as moving from flat ground to a slope.

\subsubsection{Inter-System --- Arm Kinematics Constraint}
The arm kinematics constraint bounds the relative pose between each robot base and the grasping handle (arm EE), ensuring the grasp remains within a feasible workspace. Therefore, similar to the previous technique for decomposing the system dynamics, we use the state from previous ADMM iteration. Note that due to the fixed state assumption, we need to add additional constraint for the payload with fixed robot states, maintaining the constraint feasibility from both payload and robots sides. 
\begin{equation}
\begin{aligned}
    & \v r_0 [k], \vg \theta_0[k] \in \mathcal{R}_h(^\mathcal{B} \v p_h^{\text{ref}}, \v r_i^{m}[k],\vg \theta_{i}^{m}[k], \v p_h^{\text{max}})\\ 
    \nonumber
    & \forall i \in [1,\dots,R], j \in [n_f]\\
    \label{eq:arm_rom}
    & \v r_{i}[k], \vg \theta_{i}[k] \in \mathcal{R}_h(^\mathcal{B} \v p_h^{\text{ref}}, \v r_0^{m}[k],\vg \theta_{0}^{m}[k], \v p_h^{\text{max}})
\end{aligned}
\end{equation}
where $\mathcal{R}_h$ is defined as a box constraint defining a nominal arm workspace.

\subsubsection{Inter-System --- Formation Constraint}
The formation constraint keeps each robot’s center of mass near its nominal offset from the payload in the payload frame. Although similar to the arm kinematics constraint, it empirically enhances team-level obstacle avoidance and mitigates the risk of individual robots or the payload getting trapped in local minima. As with other inter-system constraints, it is enforced in a distributed manner by using the other subsystem’s state from the previous ADMM iteration.

% Let $\v r_0[k]$, $\vg \theta_0[k]$ and $R_0(\vg \theta_0[k])$ be the payload position and orientation.
% For robot $i \in \{1,\dots,R\}$, let $\v o_i \in \mathbb{R}^3$ be the nominal offset from payload position to robot $i$ base position expressed in the payload frame. With position tolerance $\v \delta \in \mathbb{R}^3$,
% \begin{equation}
%     -\v \delta \leq \bigl( R_0(\vg \theta_0[k])^\top (\v r_i[k] - \v r_0[k]) \bigr) - (\v o_i) \leq \v \delta.
% \end{equation}
% where $(\v o_i)$ defines a constant box offset.
% This couples payload and robot states and is enforced as a soft constraint; 

\subsection{Cost Function}
The cost function is directly defined for each rigid body separately, consisting of simple tracking costs and regularization terms governed by diagonal matrices $\v Q$ and $\v R$. 
\begin{equation}
    l_k^{i} = \delta \vg \phi_Q[k]^T\mathbf{Q}\hspace{2pt}\delta \vg \phi_Q[k] + \vg \phi_R[k]^{T}\mathbf{R}\vg \phi_R[k]
\end{equation}
where $\delta \vg \phi_Q$ and $\vg \phi_R$ are defined as:
\begin{equation}
    \delta \vg \phi_Q = \v x_i - \v x_i^{\text{ref}}, \vg \phi_R = \v u_i
\end{equation}

Tracking costs include deviation from the desired base and foot EE trajectories. The regularization term includes minimizing the foot and arm EE velocities, and contact forces to encourage motion smoothness. 
% The weights for the tracking terms are defined in Table~\ref{tab:cost_weights}.

\subsection{Distributed Update}
Now we are able to adopt \textit{consensus} ADMM to update each subproblem separately. Based on the decomposition from previous sections, the overall optimization for each ADMM iteration now can be further written as:
\begin{subequations} 
\begin{align}
	\underset{\vg \phi_0,\dots,\vg \phi_N}{\text{min}} \ \mathcal{C} \coloneqq & \sum_{i = 0}^{R}(\sum_{k = 0}^{N-1}l_k^i(\v x_{i}[k], \v u_{i}[k]) + l_N^i(\v x_{i}[N])) \\\label{eq:payload_dynamics}
	\text{s.t.} \quad & \v x_{0}[k+1] = \mathcal{D}^0(\v x_{0}[k], \v u_{0}[k]) \\\label{eq:payload_constraint}
    % & \v g^0(\v x_{0, k}, \v u_{0, k}) = 0 \\
    & \v h_0(\v x_{0}[k], \v u_{0}[k]) \leq 0\\
    & \forall i \in \{1, \dots, R\} \nonumber\\\label{eq:robot_dynamics}
    & \v x_{i}[k+1] = \mathcal{D}^i(\v x_{i}[k], \v u_{i}[k]) \\\label{eq:robot_eq_constraint}
    & \v g_i(\v x_{i}[k], \v u_{i}[k]) = 0 \\
    \label{eq:robot_ineq_constraint}
    & \v h_i(\v x_{i}[k], \v u_{i}[k]) \leq 0 \\
    \label{eq:consensus_constraint_vecterized}
    & \v A_i \v u_i + \v B_i \v u_0 = 0
\end{align}
\end{subequations}
where $\v A_i$ and $\v B_i$ denote the vectorized forms of the consensus constraints defined in Eqs.~(\ref{eq:consensus_constraint}), which constitute the only coupling constraints among the subproblems.

% The augmented Lagrangian can then be written as:
% \begin{equation}
%     \begin{aligned}
%         \mathcal{L}(\vg \phi_0,\dots,\vg \phi_N,\v w) = & \sum_{i = 0}^{R}(\sum_{k = 0}^{N-1}l_k^i(\v x_{i}[k], \v u_{i}[k]) + l_N^i(\v x_{i}[N])) + \\
%         & \sum_{i = 1}^{R} \frac{\rho}{2}\|\v A_i \v u_i+\v B_i \v u_0 + \v w_i\|^2
%     \end{aligned}
% \end{equation}
Then based on ADMM, the original problem is divided into $N+1$ subproblems which are also known as sub-blocks. Each sub-block only requires part of the aforementioned AL as the local cost function:

The payload sub-block:
\begin{equation}
    \begin{aligned}
        \mathcal{L}_0(\cdot) = & \sum_{k = 0}^{N-1}l_k^0(\v x_{0}[k], \v u_{0}[k]) + l_N^0(\v x_{0}[N]) + \\
        & \sum_{i = 1}^{R} \frac{\rho}{2}\|\v A_i \v u_i+\v B_i \v u_0 + \v w_i\|^2
    \end{aligned}
\end{equation}

The $i^{\text{th}}$ robot sub-block:
\begin{equation}
    \begin{aligned}
        \mathcal{L}_i(\cdot) = & \sum_{k = 0}^{N-1}l_k^i(\v x_{i}[k], \v u_{i}[k]) + l_N^i(\v x_{i}[N]) + \\
        & \frac{\rho}{2}\|\v A_i \v u_i+\v B_i \v u_0 + \v w_i\|^2
    \end{aligned}
\end{equation}
Then for each ADMM iteration $m$, the updating sequence in a scaled form is
\begin{subequations}\label{eq:updates}
    \begin{align}
       \label{eq:primal-a}
        &\vg \phi_0^{m+1}=\underset{\vg \phi_0}{\arg\min} \ \mathcal{L}_{0}(\vg \phi_0, \vg \phi_1^{m},\dots, \vg \phi_N^{m}, \v w^{m})  \\\nonumber &\hspace{1.2cm} \text{s.t. Eq. }(\rm \ref{eq:payload_dynamics}), \text{Eq. }{\rm (\ref{eq:payload_constraint})}
        \\ \nonumber
        & \forall i \in [1,\dots,R],\\
        % \\
        % \label{eq:primal-b-1} 
        % &\vg \phi_1^{m+1}=\underset{\vg \phi_1}{\arg\min} \ \mathcal{L}_{1}(\vg \phi_0^{m+1}, \vg \phi_1, \v w^{m})\\
        % \nonumber &\hspace{1.2cm} \text{s.t. Eq. }(\rm \ref{eq:robot_dynamics}), \text{Eqs. }{\rm (\ref{eq:robot_eq_constraint} - \ref{eq:robot_ineq_constraint})}\\
        % \nonumber & \ldots \\
        \label{eq:primal-b-i} 
        &\vg \phi_i^{m+1}=\underset{\vg \phi_i}{\arg\min} \ \mathcal{L}_{i}(\vg \phi_0^{m+1}, \vg \phi_i, \v w^{m})\\
        \nonumber &\hspace{1.2cm} \text{s.t. Eq. }(\rm \ref{eq:robot_dynamics}), \text{Eqs. }{\rm (\ref{eq:robot_eq_constraint} - \ref{eq:robot_ineq_constraint})}\\
        &\v w_{i}^{m+1}=\v w_{i}^{m}+\v A_i \v u_i^{m+1}+\v B_i \v u_0^{m+1}
    \end{align}
\end{subequations}
where for each subproblem, due to the nonlinear dynamics, we employ an Riccati-like Sequential Quadratic Programming (SQP) solver to efficiently get the reduced-size subproblem solutions. All inequality constraints are penalized with a relaxed log barrier. We adopt standard \textit{consensus} ADMM rather than the \textit{Jacobi} variant, as it provides better convergence while the payload subproblem remains inexpensive to solve. Lastly, based on the consensus constraints defined in (\ref{eq:consensus_constraint}), we define the vectorized residual as $\v s = [\v A_1 \v u_1 + \v B_i \v u_0, \dots, \v A_N \v u_N + \v B_N \v u_0]^{\top}$. Similar to \cite{zhou2020accelerated}, the stopping criteria is based on a time-scaled sum squared error with a tolerance $\epsilon$: $dt \cdot \sum_k \||\v s[k]\||_2 < \epsilon$.

\section{Real-Time Planning and Control}
\subsection{Distributed Model Predictive Control}
The distributed MPC framework involves iterative replanning based on Eq.~(\ref{eq:updates}). To accelerate convergence, we employ two warm-start strategies. First, within a single MPC solve, the solution of each subproblem from the previous ADMM iteration is used to initialize the corresponding subproblem in the current iteration. Second, across successive MPC time windows, the primal and dual solutions from the previous window are used to initialize the first ADMM iteration of the new window. For the initial time window, the dual variables are initialized to zero, and the reference trajectory is used as the primal initial guess.

\subsection{Wrench-Aware Whole-Body Control}
% The wrench-aware WBC executes the planned motion and interaction wrenches at a higher control rate (500 Hz), closing the loop between the distributed MPC and the robot actuators. It takes as references the optimized base, foot, arm end-effector pose, and the 6-DoF manipulation wrench from the distributed MPC planner. The WBC solves for generalized accelerations, foot contact forces, arm end-effector wrench, and joint torques, subject to the equations of motion and contact/friction constraints.

The wrench-aware WBC executes the planned motion and interaction wrenches at 500 Hz, closing the loop between the distributed MPC and the actuators. It tracks the optimized base, foot, and arm end-effector poses together with the desired manipulation wrench, solving for generalized accelerations, contact forces, and joint torques. Inverse kinematics (IK) provides joint position and velocity references for both legs and arm, and the final torque command combines WBC feedforward torques with low-gain PD feedback to realize the desired motion and interaction wrenches while compensating residual tracking errors.

A central design choice is the task hierarchy. We adopt a hierarchical quadratic program (QP) with two priority levels rather than a single weighted QP, so that safety and dynamic consistency are never traded off for tracking. In the highest priority, we enforce: the floating-base equations of motion, joint torque limits, friction cones for feet and arm contact, no-contact motion for swing legs, the arm contact wrench tracking task, and the leg contact force tracking task given the MPC desired states. In the second level, we minimize a weighted combination of base acceleration tracking, swing-leg task, arm end-effector pose tracking, and torque/joint-acceleration regularization. This structure guarantees strict wrench tracking while utilizing remaining redundancy for pose objectives.

% In the feedback path, inverse kinematics (IK) supplies desired joint positions and velocities for both legs and the arm: leg IK (analytical) maps desired foot poses from the centroidal plan to leg joint references $q_{\mathrm{ref}}^{\mathrm{leg}}$, $\dot{q}_{\mathrm{ref}}^{\mathrm{leg}} \in \mathbb{R}^{12}$, and arm IK maps the desired end-effector pose to arm joint references $q_{\mathrm{ref}}^{\mathrm{arm}}$, $\dot{q}_{\mathrm{ref}}^{\mathrm{arm}} \in \mathbb{R}^6$. Stacking leg and arm quantities, let $q$, $\dot{q}$, $q_{\mathrm{ref}}$, $\dot{q}_{\mathrm{ref}} \in \mathbb{R}^n$ with $n = 18$ denote measured and reference joint positions and velocities, and let $\tau_{\mathrm{ff}} \in \mathbb{R}^n$ be the feedforward torque from the WBC. The final commanded torque for legs and arm is
% \begin{equation}
%   \tau = \tau_{\mathrm{ff}} + K_p (q_{\mathrm{ref}} - q) + K_d (\dot{q}_{\mathrm{ref}} - \dot{q}),
% \end{equation}
% where $K_p$, $K_d \in \mathbb{R}^{n \times n}$ are block-diagonal gain matrices (leg and arm blocks). The feedforward term realizes the desired wrenches and motion from the WBC; the PD feedback corrects tracking errors and adds damping for both locomotion and manipulation. The PD gains are kept low, leveraging feedforward compensation to maintain tracking performance without excessive feedback gains.

% \subsection{Task Executor via Behavior-Tree}
% Pre-grasping $\rightarrow$ Gait selection $\rightarrow$ Carrying $\rightarrow$